/*=============================================================================
	Author:			Eric M. Barnard - @ericmbarnard								
	License:		MIT (http://opensource.org/licenses/mit-license.php)		
																				
	Description:	Validation Library for KnockoutJS							
	Version:		2.0.3											
===============================================================================
*/

!function(factory) {
  if ("function" == typeof require && ("object" == typeof exports && "object" == typeof module)) {
    factory(require("knockout"), exports);
  } else {
    if ("function" == typeof define && define.amd) {
      define(["knockout", "exports"], factory);
    } else {
      factory(ko, ko.validation = {});
    }
  }
}(function(ko, a) {
  /**
   * @param {string} max
   * @return {?}
   */
  function init(max) {
    /** @type {boolean} */
    var maxnull = "max" === max;
    return function(value, t) {
      if (self.utils.isEmptyVal(value)) {
        return true;
      }
      var v;
      var result;
      if (void 0 === t.typeAttr) {
        /** @type {string} */
        result = "text";
        /** @type {string} */
        v = t;
      } else {
        result = t.typeAttr;
        v = t.value;
      }
      if (!isNaN(v)) {
        if (!(v instanceof Date)) {
          /** @type {string} */
          result = "number";
        }
      }
      var r;
      var a;
      var b;
      switch(result.toLowerCase()) {
        case "week":
          if (r = /^(\d{4})-W(\d{2})$/, a = value.match(r), null === a) {
            throw new Error("Invalid value for " + max + " attribute for week input.  Should look like '2000-W33' http://www.w3.org/TR/html-markup/input.week.html#input.week.attrs.min");
          }
          return b = v.match(r), b ? maxnull ? a[1] < b[1] || a[1] === b[1] && a[2] <= b[2] : a[1] > b[1] || a[1] === b[1] && a[2] >= b[2] : false;
        case "month":
          if (r = /^(\d{4})-(\d{2})$/, a = value.match(r), null === a) {
            throw new Error("Invalid value for " + max + " attribute for month input.  Should look like '2000-03' http://www.w3.org/TR/html-markup/input.month.html#input.month.attrs.min");
          }
          return b = v.match(r), b ? maxnull ? a[1] < b[1] || a[1] === b[1] && a[2] <= b[2] : a[1] > b[1] || a[1] === b[1] && a[2] >= b[2] : false;
        case "number":
        ;
        case "range":
          return maxnull ? !isNaN(value) && parseFloat(value) <= parseFloat(v) : !isNaN(value) && parseFloat(value) >= parseFloat(v);
        default:
          return maxnull ? v >= value : value >= v;
      }
    };
  }
  /**
   * @param {Object} observable
   * @param {Object} rule
   * @param {Object} args
   * @return {?}
   */
  function validateSync(observable, rule, args) {
    return rule.validator(observable(), void 0 === args.params ? true : isArray(args.params)) ? true : (observable.setError(self.formatMessage(args.message || rule.message, isArray(args.params), observable)), false);
  }
  /**
   * @param {Object} observable
   * @param {Object} rule
   * @param {Object} opts
   * @return {undefined}
   */
  function traverse(observable, rule, opts) {
    observable.isValidating(true);
    /**
     * @param {Object} valObj
     * @return {?}
     */
    var callBack = function(valObj) {
      /** @type {boolean} */
      var isValid = false;
      /** @type {string} */
      var msg = "";
      return observable.__valid__() ? (valObj.message ? (isValid = valObj.isValid, msg = valObj.message) : isValid = valObj, isValid || (observable.error(self.formatMessage(msg || (opts.message || rule.message), isArray(opts.params), observable)), observable.__valid__(isValid)), void observable.isValidating(false)) : void observable.isValidating(false);
    };
    self.utils.async(function() {
      rule.validator(observable(), void 0 === opts.params ? true : isArray(opts.params), callBack);
    });
  }
  if ("undefined" == typeof ko) {
    throw new Error("Knockout is required, please ensure it is loaded before loading this validation plug-in");
  }
  /** @type {string} */
  ko.validation = a;
  var self = ko.validation;
  var utils = ko.utils;
  var isArray = utils.unwrapObservable;
  var forEach = utils.arrayForEach;
  var extend = utils.extend;
  var defaults = {
    registerExtenders : true,
    messagesOnModified : true,
    errorsAsTitle : true,
    errorsAsTitleOnModified : false,
    messageTemplate : null,
    insertMessages : true,
    parseInputAttributes : false,
    writeInputAttributes : false,
    decorateInputElement : false,
    decorateElementOnModified : true,
    errorClass : null,
    errorElementClass : "validationElement",
    errorMessageClass : "validationMessage",
    allowHtmlMessages : false,
    grouping : {
      deep : false,
      observable : true,
      live : false
    },
    validate : {}
  };
  var config = extend({}, defaults);
  /** @type {Array} */
  config.html5Attributes = ["required", "pattern", "min", "max", "step"];
  /** @type {Array} */
  config.html5InputTypes = ["email", "number", "date"];
  /**
   * @return {undefined}
   */
  config.reset = function() {
    extend(config, defaults);
  };
  self.configuration = config;
  self.utils = function() {
    /** @type {number} */
    var a = (new Date).getTime();
    var $cookies = {};
    /** @type {string} */
    var domDataKey = "__ko_validation__";
    return{
      /**
       * @param {Function} obj
       * @return {?}
       */
      isArray : function(obj) {
        return obj.isArray || "[object Array]" === Object.prototype.toString.call(obj);
      },
      /**
       * @param {Object} obj
       * @return {?}
       */
      isObject : function(obj) {
        return null !== obj && "object" == typeof obj;
      },
      /**
       * @param {(Object|string)} val
       * @return {?}
       */
      isNumber : function(val) {
        return!isNaN(val);
      },
      /**
       * @param {string} result
       * @return {?}
       */
      isObservableArray : function(result) {
        return!!result && ("function" == typeof result.remove && ("function" == typeof result.removeAll && ("function" == typeof result.destroy && ("function" == typeof result.destroyAll && ("function" == typeof result.indexOf && "function" == typeof result.replace)))));
      },
      /**
       * @param {Object} obj
       * @return {?}
       */
      values : function(obj) {
        /** @type {Array} */
        var values = [];
        var property;
        for (property in obj) {
          if (obj.hasOwnProperty(property)) {
            values.push(obj[property]);
          }
        }
        return values;
      },
      /**
       * @param {?} callback
       * @return {?}
       */
      getValue : function(callback) {
        return "function" == typeof callback ? callback() : callback;
      },
      /**
       * @param {Element} el
       * @param {string} attribute
       * @return {?}
       */
      hasAttribute : function(el, attribute) {
        return null !== el.getAttribute(attribute);
      },
      /**
       * @param {Node} attr
       * @param {string} name
       * @return {?}
       */
      getAttribute : function(attr, name) {
        return attr.getAttribute(name);
      },
      /**
       * @param {Element} node
       * @param {Element} name
       * @param {Element} value
       * @return {?}
       */
      setAttribute : function(node, name, value) {
        return node.setAttribute(name, value);
      },
      /**
       * @param {Object} o
       * @return {?}
       */
      isValidatable : function(o) {
        return!!(o && (o.rules && (o.isValid && o.isModified)));
      },
      /**
       * @param {Element} el
       * @param {Element} newNode
       * @return {undefined}
       */
      insertAfter : function(el, newNode) {
        el.parentNode.insertBefore(newNode, el.nextSibling);
      },
      /**
       * @return {?}
       */
      newId : function() {
        return a += 1;
      },
      /**
       * @param {Element} element
       * @return {?}
       */
      getConfigOptions : function(element) {
        var s = self.utils.contextFor(element);
        return s || self.configuration;
      },
      /**
       * @param {Object} node
       * @param {?} b
       * @return {undefined}
       */
      setDomData : function(node, b) {
        var key = node[domDataKey];
        if (!key) {
          node[domDataKey] = key = self.utils.newId();
        }
        $cookies[key] = b;
      },
      /**
       * @param {Node} node
       * @return {?}
       */
      getDomData : function(node) {
        var key = node[domDataKey];
        return key ? $cookies[key] : void 0;
      },
      /**
       * @param {Node} node
       * @return {?}
       */
      contextFor : function(node) {
        switch(node.nodeType) {
          case 1:
          ;
          case 8:
            var context = self.utils.getDomData(node);
            if (context) {
              return context;
            }
            if (node.parentNode) {
              return self.utils.contextFor(node.parentNode);
            }
          ;
        }
        return void 0;
      },
      /**
       * @param {Object} elems
       * @return {?}
       */
      isEmptyVal : function(elems) {
        return void 0 === elems ? true : null === elems ? true : "" === elems ? true : void 0;
      },
      /**
       * @param {Element} attr
       * @return {?}
       */
      getOriginalElementTitle : function(attr) {
        var str = self.utils.getAttribute(attr, "data-orig-title");
        var text = attr.title;
        var escape = self.utils.hasAttribute(attr, "data-orig-title");
        return escape ? str : text;
      },
      /**
       * @param {Function} cb
       * @return {undefined}
       */
      async : function(cb) {
        if (window.setImmediate) {
          window.setImmediate(cb);
        } else {
          window.setTimeout(cb, 0);
        }
      },
      /**
       * @param {Object} obj
       * @param {Function} func
       * @return {?}
       */
      forEach : function(obj, func) {
        if (self.utils.isArray(obj)) {
          return forEach(obj, func);
        }
        var prop;
        for (prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            func(obj[prop], prop);
          }
        }
      }
    };
  }();
  var oldconfig = function() {
    /**
     * @param {Element} keepData
     * @return {undefined}
     */
    function remove(keepData) {
      forEach(keepData.subscriptions, function(child) {
        child.dispose();
      });
      /** @type {Array} */
      keepData.subscriptions = [];
    }
    /**
     * @param {Element} node
     * @return {undefined}
     */
    function check(node) {
      if (node.options.deep) {
        forEach(node.flagged, function(dataAndEvents) {
          delete dataAndEvents.__kv_traversed;
        });
        /** @type {number} */
        node.flagged.length = 0;
      }
      if (!node.options.live) {
        remove(node);
      }
    }
    /**
     * @param {?} obj
     * @param {Element} key
     * @return {undefined}
     */
    function next(obj, key) {
      /** @type {Array} */
      key.validatables = [];
      remove(key);
      traverse(obj, key);
      check(key);
    }
    /**
     * @param {Object} obj
     * @param {Element} callback
     * @param {number} object
     * @return {undefined}
     */
    function traverse(obj, callback, object) {
      /** @type {Array} */
      var suiteView = [];
      var copy = obj.peek ? obj.peek() : obj;
      if (obj.__kv_traversed !== true) {
        if (callback.options.deep) {
          /** @type {boolean} */
          obj.__kv_traversed = true;
          callback.flagged.push(obj);
        }
        object = void 0 !== object ? object : callback.options.deep ? 1 : -1;
        if (ko.isObservable(obj)) {
          if (!obj.errors) {
            if (!utils.isValidatable(obj)) {
              obj.extend({
                validatable : true
              });
            }
          }
          callback.validatables.push(obj);
          if (callback.options.live) {
            if (utils.isObservableArray(obj)) {
              callback.subscriptions.push(obj.subscribe(function() {
                callback.graphMonitor.valueHasMutated();
              }));
            }
          }
        }
        if (copy) {
          if (!copy._destroy) {
            if (utils.isArray(copy)) {
              suiteView = copy;
            } else {
              if (utils.isObject(copy)) {
                suiteView = utils.values(copy);
              }
            }
          }
        }
        if (0 !== object) {
          utils.forEach(suiteView, function(observable) {
            if (!!observable) {
              if (!observable.nodeType) {
                if (!(ko.isComputed(observable) && !observable.rules)) {
                  traverse(observable, callback, object + 1);
                }
              }
            }
          });
        }
      }
    }
    /**
     * @param {Array} callbacks
     * @return {?}
     */
    function complete(callbacks) {
      /** @type {Array} */
      var eventPath = [];
      return forEach(callbacks, function(observable) {
        if (utils.isValidatable(observable)) {
          if (!observable.isValid()) {
            eventPath.push(observable.error.peek());
          }
        }
      }), eventPath;
    }
    /** @type {number} */
    var isInitialized = 0;
    var configuration = self.configuration;
    var utils = self.utils;
    return{
      /**
       * @param {Object} options
       * @param {?} force
       * @return {undefined}
       */
      init : function(options, force) {
        if (!(isInitialized > 0 && !force)) {
          options = options || {};
          options.errorElementClass = options.errorElementClass || (options.errorClass || configuration.errorElementClass);
          options.errorMessageClass = options.errorMessageClass || (options.errorClass || configuration.errorMessageClass);
          extend(configuration, options);
          if (configuration.registerExtenders) {
            self.registerExtenders();
          }
          /** @type {number} */
          isInitialized = 1;
        }
      },
      reset : self.configuration.reset,
      /**
       * @param {?} error
       * @param {Object} params
       * @return {?}
       */
      group : function(error, params) {
        params = extend(extend({}, configuration.grouping), params);
        var data = {
          options : params,
          graphMonitor : ko.observable(),
          flagged : [],
          subscriptions : [],
          validatables : []
        };
        /** @type {null} */
        var all = null;
        return all = params.observable ? ko.computed(function() {
          return data.graphMonitor(), next(error, data), complete(data.validatables);
        }) : function() {
          return next(error, data), complete(data.validatables);
        }, all.showAllMessages = function(show) {
          if (void 0 === show) {
            /** @type {boolean} */
            show = true;
          }
          all.forEach(function(observable) {
            if (utils.isValidatable(observable)) {
              observable.isModified(show);
            }
          });
        }, all.isAnyMessageShown = function() {
          var a;
          return a = !!all.find(function(observable) {
            return utils.isValidatable(observable) && (!observable.isValid() && observable.isModified());
          });
        }, all.filter = function(selector) {
          return selector = selector || function() {
            return true;
          }, all(), utils.arrayFilter(data.validatables, selector);
        }, all.find = function(results) {
          return results = results || function() {
            return true;
          }, all(), utils.arrayFirst(data.validatables, results);
        }, all.forEach = function(obj) {
          obj = obj || function() {
          };
          all();
          forEach(data.validatables, obj);
        }, all.map = function(cb) {
          return cb = cb || function(result) {
            return result;
          }, all(), utils.arrayMap(data.validatables, cb);
        }, all._updateState = function(err) {
          if (!utils.isObject(err)) {
            throw new Error("An object is required.");
          }
          return error = err, params.observable ? void data.graphMonitor.valueHasMutated() : (next(err, data), complete(data.validatables));
        }, all;
      },
      /**
       * @param {string} f
       * @param {string} msg
       * @param {Object} type
       * @return {?}
       */
      formatMessage : function(f, msg, type) {
        if (utils.isObject(msg) && (msg.typeAttr && (msg = msg.value)), "function" == typeof f) {
          return f(msg, type);
        }
        var copy = isArray(msg);
        return null == copy && (copy = []), utils.isArray(copy) || (copy = [copy]), f.replace(/{(\d+)}/gi, function(dataAndEvents, attr) {
          return "undefined" != typeof copy[attr] ? copy[attr] : dataAndEvents;
        });
      },
      /**
       * @param {Object} obj
       * @param {Node} value
       * @return {?}
       */
      addRule : function(obj, value) {
        obj.extend({
          validatable : true
        });
        /** @type {boolean} */
        var passed = !!utils.arrayFirst(obj.rules(), function(node) {
          return node.rule && node.rule === value.rule;
        });
        return passed || obj.rules.push(value), obj;
      },
      /**
       * @param {?} observable
       * @param {Object} code
       * @return {undefined}
       */
      addAnonymousRule : function(observable, code) {
        if (void 0 === code.message) {
          /** @type {string} */
          code.message = "Error";
        }
        if (code.onlyIf) {
          code.condition = code.onlyIf;
        }
        self.addRule(observable, code);
      },
      /**
       * @param {string} ruleName
       * @return {undefined}
       */
      addExtender : function(ruleName) {
        /**
         * @param {Object} property
         * @param {Object} params
         * @return {?}
         */
        ko.extenders[ruleName] = function(property, params) {
          return params && (params.message || params.onlyIf) ? self.addRule(property, {
            rule : ruleName,
            message : params.message,
            params : utils.isEmptyVal(params.params) ? true : params.params,
            condition : params.onlyIf
          }) : self.addRule(property, {
            rule : ruleName,
            params : params
          });
        };
      },
      /**
       * @return {undefined}
       */
      registerExtenders : function() {
        if (configuration.registerExtenders) {
          var ruleName;
          for (ruleName in self.rules) {
            if (self.rules.hasOwnProperty(ruleName)) {
              if (!ko.extenders[ruleName]) {
                self.addExtender(ruleName);
              }
            }
          }
        }
      },
      /**
       * @param {Element} element
       * @return {?}
       */
      insertValidationMessage : function(element) {
        /** @type {Element} */
        var span = document.createElement("SPAN");
        return span.className = utils.getConfigOptions(element).errorMessageClass, utils.insertAfter(element, span), span;
      },
      /**
       * @param {Element} element
       * @param {?} valueAccessor
       * @return {undefined}
       */
      parseInputValidationAttributes : function(element, valueAccessor) {
        forEach(self.configuration.html5Attributes, function(attr) {
          if (utils.hasAttribute(element, attr)) {
            var params = element.getAttribute(attr) || true;
            if ("min" === attr || "max" === attr) {
              var el = element.getAttribute("type");
              if (!("undefined" != typeof el && el)) {
                /** @type {string} */
                el = "text";
              }
              params = {
                typeAttr : el,
                value : params
              };
            }
            self.addRule(valueAccessor(), {
              rule : attr,
              params : params
            });
          }
        });
        var target = element.getAttribute("type");
        forEach(self.configuration.html5InputTypes, function(value) {
          if (value === target) {
            self.addRule(valueAccessor(), {
              rule : "date" === value ? "dateISO" : value,
              params : true
            });
          }
        });
      },
      /**
       * @param {Element} element
       * @param {?} valueAccessor
       * @return {undefined}
       */
      writeInputValidationAttributes : function(element, valueAccessor) {
        var options = valueAccessor();
        if (options && options.rules) {
          var opt = options.rules();
          forEach(self.configuration.html5Attributes, function(attribute) {
            var options = utils.arrayFirst(opt, function(e) {
              return e.rule && e.rule.toLowerCase() === attribute.toLowerCase();
            });
            if (options) {
              ko.computed({
                /**
                 * @return {undefined}
                 */
                read : function() {
                  var p = ko.unwrap(options.params);
                  if ("pattern" === options.rule) {
                    if (p instanceof RegExp) {
                      /** @type {string} */
                      p = p.source;
                    }
                  }
                  element.setAttribute(attribute, p);
                },
                disposeWhenNodeIsRemoved : element
              });
            }
          });
          /** @type {null} */
          opt = null;
        }
      },
      /**
       * @param {string} name
       * @return {undefined}
       */
      makeBindingHandlerValidatable : function(name) {
        var init = ko.bindingHandlers[name].init;
        /**
         * @param {Element} element
         * @param {?} valueAccessor
         * @param {?} allBindingsAccessor
         * @param {?} lineNumber
         * @param {?} bindingContext
         * @return {?}
         */
        ko.bindingHandlers[name].init = function(element, valueAccessor, allBindingsAccessor, lineNumber, bindingContext) {
          return init(element, valueAccessor, allBindingsAccessor, lineNumber, bindingContext), ko.bindingHandlers.validationCore.init(element, valueAccessor, allBindingsAccessor, lineNumber, bindingContext);
        };
      },
      /**
       * @param {Object} syntax
       * @param {Object} rule
       * @return {undefined}
       */
      setRules : function(syntax, rule) {
        /**
         * @param {Object} object
         * @param {Object} path
         * @return {undefined}
         */
        var traverse = function(object, path) {
          if (object && path) {
            var key;
            for (key in path) {
              if (path.hasOwnProperty(key)) {
                var prop = path[key];
                if (object[key]) {
                  var value = object[key];
                  var obj = isArray(value);
                  var prototype = {};
                  var target = {};
                  var name;
                  for (name in prop) {
                    if (prop.hasOwnProperty(name)) {
                      if (self.rules[name]) {
                        prototype[name] = prop[name];
                      } else {
                        target[name] = prop[name];
                      }
                    }
                  }
                  if (ko.isObservable(value) && value.extend(prototype), obj && utils.isArray(obj)) {
                    /** @type {number} */
                    var i = 0;
                    for (;i < obj.length;i++) {
                      traverse(obj[i], target);
                    }
                  } else {
                    traverse(obj, target);
                  }
                }
              }
            }
          }
        };
        traverse(syntax, rule);
      }
    };
  }();
  extend(ko.validation, oldconfig);
  self.rules = {};
  self.rules.required = {
    /**
     * @param {number} line
     * @param {boolean} baseValue
     * @return {?}
     */
    validator : function(line, baseValue) {
      var str;
      return void 0 === line || null === line ? !baseValue : (str = line, "string" == typeof line && (str = String.prototype.trim ? line.trim() : line.replace(/^\s+|\s+$/g, "")), baseValue ? (str + "").length > 0 : true);
    },
    message : "This field is required."
  };
  self.rules.min = {
    validator : init("min"),
    message : "Please enter a value greater than or equal to {0}."
  };
  self.rules.max = {
    validator : init("max"),
    message : "Please enter a value less than or equal to {0}."
  };
  self.rules.minLength = {
    /**
     * @param {(Object|string)} val
     * @param {?} params
     * @return {?}
     */
    validator : function(val, params) {
      if (self.utils.isEmptyVal(val)) {
        return true;
      }
      var codeSegments = self.utils.isNumber(val) ? "" + val : val;
      return codeSegments.length >= params;
    },
    message : "Please enter at least {0} characters."
  };
  self.rules.maxLength = {
    /**
     * @param {(Object|string)} val
     * @param {?} value
     * @return {?}
     */
    validator : function(val, value) {
      if (self.utils.isEmptyVal(val)) {
        return true;
      }
      var codeSegments = self.utils.isNumber(val) ? "" + val : val;
      return codeSegments.length <= value;
    },
    message : "Please enter no more than {0} characters."
  };
  self.rules.pattern = {
    /**
     * @param {Object} val
     * @param {?} regex
     * @return {?}
     */
    validator : function(val, regex) {
      return self.utils.isEmptyVal(val) || null !== val.toString().match(regex);
    },
    message : "Please check this value."
  };
  self.rules.step = {
    /**
     * @param {number} val
     * @param {number} baseValue
     * @return {?}
     */
    validator : function(val, baseValue) {
      if (self.utils.isEmptyVal(val) || "any" === baseValue) {
        return true;
      }
      /** @type {number} */
      var avg = 100 * val % (100 * baseValue);
      return Math.abs(avg) < 1E-5 || Math.abs(1 - avg) < 1E-5;
    },
    message : "The value must increment by {0}."
  };
  self.rules.email = {
    /**
     * @param {Object} val
     * @param {boolean} validate
     * @return {?}
     */
    validator : function(val, validate) {
      return validate ? self.utils.isEmptyVal(val) || validate && /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(val) : 
      true;
    },
    message : "Please enter a proper email address."
  };
  self.rules.date = {
    /**
     * @param {string} val
     * @param {boolean} validate
     * @return {?}
     */
    validator : function(val, validate) {
      return validate ? self.utils.isEmptyVal(val) || validate && !/Invalid|NaN/.test(new Date(val)) : true;
    },
    message : "Please enter a proper date."
  };
  self.rules.dateISO = {
    /**
     * @param {Object} val
     * @param {boolean} validate
     * @return {?}
     */
    validator : function(val, validate) {
      return validate ? self.utils.isEmptyVal(val) || validate && /^\d{4}[-/](?:0?[1-9]|1[012])[-/](?:0?[1-9]|[12][0-9]|3[01])$/.test(val) : true;
    },
    message : "Please enter a proper date."
  };
  self.rules.number = {
    /**
     * @param {Object} val
     * @param {boolean} validate
     * @return {?}
     */
    validator : function(val, validate) {
      return validate ? self.utils.isEmptyVal(val) || validate && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(val) : true;
    },
    message : "Please enter a number."
  };
  self.rules.digit = {
    /**
     * @param {Object} val
     * @param {boolean} validate
     * @return {?}
     */
    validator : function(val, validate) {
      return validate ? self.utils.isEmptyVal(val) || validate && /^\d+$/.test(val) : true;
    },
    message : "Please enter a digit."
  };
  self.rules.phoneUS = {
    /**
     * @param {string} val
     * @param {boolean} baseValue
     * @return {?}
     */
    validator : function(val, baseValue) {
      return baseValue ? self.utils.isEmptyVal(val) ? true : "string" != typeof val ? false : (val = val.replace(/\s+/g, ""), baseValue && (val.length > 9 && val.match(/^(1-?)?(\([2-9]\d{2}\)|[2-9]\d{2})-?[2-9]\d{2}-?\d{4}$/))) : true;
    },
    message : "Please specify a valid phone number."
  };
  self.rules.equal = {
    /**
     * @param {?} baseValue
     * @param {?} attribute
     * @return {?}
     */
    validator : function(baseValue, attribute) {
      var restoreScript = attribute;
      return baseValue === self.utils.getValue(restoreScript);
    },
    message : "Values must equal."
  };
  self.rules.notEqual = {
    /**
     * @param {?} baseValue
     * @param {?} attribute
     * @return {?}
     */
    validator : function(baseValue, attribute) {
      var restoreScript = attribute;
      return baseValue !== self.utils.getValue(restoreScript);
    },
    message : "Please choose another value."
  };
  self.rules.unique = {
    /**
     * @param {Object} val
     * @param {?} options
     * @return {?}
     */
    validator : function(val, options) {
      var validObj = self.utils.getValue(options.collection);
      var d = self.utils.getValue(options.externalValue);
      /** @type {number} */
      var e = 0;
      return val && validObj ? (utils.arrayFilter(validObj, function(item) {
        if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) {
          e++;
        }
      }), (d ? 1 : 2) > e) : true;
    },
    message : "Please make sure the value is unique."
  };
  (function() {
    self.registerExtenders();
  })();
  ko.bindingHandlers.validationCore = function() {
    return{
      /**
       * @param {Element} element
       * @param {?} valueAccessor
       * @return {undefined}
       */
      init : function(element, valueAccessor) {
        var config = self.utils.getConfigOptions(element);
        var value = valueAccessor();
        if (config.parseInputAttributes && self.utils.async(function() {
          self.parseInputValidationAttributes(element, valueAccessor);
        }), config.insertMessages && self.utils.isValidatable(value)) {
          var validationMessageElement = self.insertValidationMessage(element);
          if (config.messageTemplate) {
            ko.renderTemplate(config.messageTemplate, {
              field : value
            }, null, validationMessageElement, "replaceNode");
          } else {
            ko.applyBindingsToNode(validationMessageElement, {
              validationMessage : value
            });
          }
        }
        if (config.writeInputAttributes) {
          if (self.utils.isValidatable(value)) {
            self.writeInputValidationAttributes(element, valueAccessor);
          }
        }
        if (config.decorateInputElement) {
          if (self.utils.isValidatable(value)) {
            ko.applyBindingsToNode(element, {
              validationElement : value
            });
          }
        }
      }
    };
  }();
  self.makeBindingHandlerValidatable("value");
  self.makeBindingHandlerValidatable("checked");
  if (ko.bindingHandlers.textInput) {
    self.makeBindingHandlerValidatable("textInput");
  }
  self.makeBindingHandlerValidatable("selectedOptions");
  ko.bindingHandlers.validationMessage = {
    /**
     * @param {Element} element
     * @param {Function} valueAccessor
     * @return {undefined}
     */
    update : function(element, valueAccessor) {
      var args = valueAccessor();
      var elementRect = self.utils.getConfigOptions(element);
      /** @type {boolean} */
      var i = (isArray(args), false);
      /** @type {boolean} */
      var strip = false;
      if (null === args || "undefined" == typeof args) {
        throw new Error("Cannot bind validationMessage to undefined value. data-bind expression: " + element.getAttribute("data-bind"));
      }
      i = args.isModified && args.isModified();
      strip = args.isValid && args.isValid();
      /** @type {null} */
      var content = null;
      if (!elementRect.messagesOnModified || i) {
        content = strip ? null : args.error;
      }
      /** @type {boolean} */
      var _isFocused = !elementRect.messagesOnModified || i ? !strip : false;
      /** @type {boolean} */
      var _tryInitOnFocus = "none" !== element.style.display;
      if (elementRect.allowHtmlMessages) {
        utils.setHtml(element, content);
      } else {
        ko.bindingHandlers.text.update(element, function() {
          return content;
        });
      }
      if (_tryInitOnFocus && !_isFocused) {
        /** @type {string} */
        element.style.display = "none";
      } else {
        if (!_tryInitOnFocus) {
          if (_isFocused) {
            /** @type {string} */
            element.style.display = "";
          }
        }
      }
    }
  };
  ko.bindingHandlers.validationElement = {
    /**
     * @param {Element} element
     * @param {Function} valueAccessor
     * @param {?} allBindingsAccessor
     * @return {undefined}
     */
    update : function(element, valueAccessor, allBindingsAccessor) {
      var args = valueAccessor();
      var config = self.utils.getConfigOptions(element);
      /** @type {boolean} */
      var file = (isArray(args), false);
      /** @type {boolean} */
      var modifiedOnly = false;
      if (null === args || "undefined" == typeof args) {
        throw new Error("Cannot bind validationElement to undefined value. data-bind expression: " + element.getAttribute("data-bind"));
      }
      file = args.isModified && args.isModified();
      modifiedOnly = args.isValid && args.isValid();
      /**
       * @return {?}
       */
      var cssSettingsAccessor = function() {
        var css = {};
        /** @type {boolean} */
        var transformString = !config.decorateElementOnModified || file ? !modifiedOnly : false;
        return css[config.errorElementClass] = transformString, css;
      };
      ko.bindingHandlers.css.update(element, cssSettingsAccessor, allBindingsAccessor);
      if (config.errorsAsTitle) {
        ko.bindingHandlers.attr.update(element, function() {
          var attrs = !config.errorsAsTitleOnModified || file;
          var child = self.utils.getOriginalElementTitle(element);
          return attrs && !modifiedOnly ? {
            title : args.error,
            "data-orig-title" : child
          } : !attrs || modifiedOnly ? {
            title : child,
            "data-orig-title" : null
          } : void 0;
        });
      }
    }
  };
  ko.bindingHandlers.validationOptions = function() {
    return{
      /**
       * @param {?} element
       * @param {?} valueAccessor
       * @return {undefined}
       */
      init : function(element, valueAccessor) {
        var type0 = isArray(valueAccessor());
        if (type0) {
          var oldconfig = extend({}, self.configuration);
          extend(oldconfig, type0);
          self.utils.setDomData(element, oldconfig);
        }
      }
    };
  }();
  /**
   * @param {?} observable
   * @param {?} field
   * @return {?}
   */
  ko.extenders.validation = function(observable, field) {
    return forEach(self.utils.isArray(field) ? field : [field], function(funcToCall) {
      self.addAnonymousRule(observable, funcToCall);
    }), observable;
  };
  /**
   * @param {Object} observable
   * @param {Object} options
   * @return {?}
   */
  ko.extenders.validatable = function(observable, options) {
    if (self.utils.isObject(options) || (options = {
      enable : options
    }), "enable" in options || (options.enable = true), options.enable && !self.utils.isValidatable(observable)) {
      var utils = self.configuration.validate || {};
      var oldconfig = {
        throttleEvaluation : options.throttle || utils.throttle
      };
      observable.error = ko.observable(null);
      observable.rules = ko.observableArray();
      observable.isValidating = ko.observable(false);
      observable.__valid__ = ko.observable(true);
      observable.isModified = ko.observable(false);
      observable.isValid = ko.computed(observable.__valid__);
      /**
       * @param {?} err
       * @return {undefined}
       */
      observable.setError = function(err) {
        var e = observable.error.peek();
        var d = observable.__valid__.peek();
        observable.error(err);
        observable.__valid__(false);
        if (!(e === err)) {
          if (!d) {
            observable.isValid.notifySubscribers();
          }
        }
      };
      /**
       * @return {?}
       */
      observable.clearError = function() {
        return observable.error(null), observable.__valid__(true), observable;
      };
      var animation = observable.subscribe(function() {
        observable.isModified(true);
      });
      var wrapper = ko.computed(extend({
        /**
         * @return {?}
         */
        read : function() {
          observable();
          observable.rules();
          return self.validateObservable(observable), true;
        }
      }, oldconfig));
      extend(wrapper, oldconfig);
      /**
       * @return {undefined}
       */
      observable._disposeValidation = function() {
        observable.isValid.dispose();
        observable.rules.removeAll();
        animation.dispose();
        wrapper.dispose();
        delete observable.rules;
        delete observable.error;
        delete observable.isValid;
        delete observable.isValidating;
        delete observable.__valid__;
        delete observable.isModified;
        delete observable.setError;
        delete observable.clearError;
        delete observable._disposeValidation;
      };
    } else {
      if (options.enable === false) {
        if (observable._disposeValidation) {
          observable._disposeValidation();
        }
      }
    }
    return observable;
  };
  /**
   * @param {Object} observable
   * @return {?}
   */
  self.validateObservable = function(observable) {
    var fn;
    var options;
    /** @type {number} */
    var i = 0;
    var employees = observable.rules();
    var l = employees.length;
    for (;l > i;i++) {
      if (options = employees[i], !options.condition || options.condition()) {
        if (fn = options.rule ? self.rules[options.rule] : options, fn.async || options.async) {
          traverse(observable, fn, options);
        } else {
          if (!validateSync(observable, fn, options)) {
            return false;
          }
        }
      }
    }
    return observable.clearError(), true;
  };
  var locale;
  var obj = {};
  /**
   * @param {string} name
   * @param {boolean} value
   * @return {?}
   */
  self.defineLocale = function(name, value) {
    return name && value ? (obj[name.toLowerCase()] = value, value) : null;
  };
  /**
   * @param {string} property
   * @return {?}
   */
  self.locale = function(property) {
    if (property) {
      if (property = property.toLowerCase(), !obj.hasOwnProperty(property)) {
        throw new Error("Localization " + property + " has not been loaded.");
      }
      self.localize(obj[property]);
      /** @type {string} */
      locale = property;
    }
    return locale;
  };
  /**
   * @param {Object} msgTranslations
   * @return {undefined}
   */
  self.localize = function(msgTranslations) {
    var rules = self.rules;
    var rule;
    for (rule in msgTranslations) {
      if (rules.hasOwnProperty(rule)) {
        rules[rule].message = msgTranslations[rule];
      }
    }
  };
  (function() {
    var messages = {};
    var markers = self.rules;
    var i;
    for (i in markers) {
      if (markers.hasOwnProperty(i)) {
        messages[i] = markers[i].message;
      }
    }
    self.defineLocale("en-us", messages);
  })();
  /** @type {string} */
  locale = "en-us";
  /**
   * @param {?} viewModel
   * @param {HTMLElement} obj
   * @param {Element} a1
   * @return {undefined}
   */
  ko.applyBindingsWithValidation = function(viewModel, obj, a1) {
    var params;
    /** @type {(HTMLElement|null)} */
    var node = document.body;
    if (obj && obj.nodeType) {
      /** @type {HTMLElement} */
      node = obj;
      /** @type {Element} */
      params = a1;
    } else {
      /** @type {HTMLElement} */
      params = obj;
    }
    self.init();
    if (params) {
      params = extend(extend({}, self.configuration), params);
      self.utils.setDomData(node, params);
    }
    ko.applyBindings(viewModel, node);
  };
  /** @type {function (?, Object): undefined} */
  var origApplyBindings = ko.applyBindings;
  /**
   * @param {?} viewModel
   * @param {Object} dataAndEvents
   * @return {undefined}
   */
  ko.applyBindings = function(viewModel, dataAndEvents) {
    self.init();
    origApplyBindings(viewModel, dataAndEvents);
  };
  /**
   * @param {Object} initialValue
   * @param {Object} funcToCall
   * @return {?}
   */
  ko.validatedObservable = function(initialValue, funcToCall) {
    if (!funcToCall && !self.utils.isObject(initialValue)) {
      return ko.observable(initialValue).extend({
        validatable : true
      });
    }
    var instance = ko.observable(initialValue);
    return instance.errors = self.group(self.utils.isObject(initialValue) ? initialValue : {}, funcToCall), instance.isValid = ko.observable(0 === instance.errors().length), ko.isObservable(instance.errors) ? instance.errors.subscribe(function(newlines) {
      instance.isValid(0 === newlines.length);
    }) : ko.computed(instance.errors).subscribe(function(newlines) {
      instance.isValid(0 === newlines.length);
    }), instance.subscribe(function(elt) {
      if (!self.utils.isObject(elt)) {
        elt = {};
      }
      instance.errors._updateState(elt);
      instance.isValid(0 === instance.errors().length);
    }), instance;
  };
});

/* sourceMappingURL=knockout.validation.min.js.map*/